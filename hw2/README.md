# Возводим стены проекта! 

## Хрен вам, а не ресурсы! 

Мы уже говорили ранее, что мы не хотим, чтобы какие-то рандомные люди использовали наши ресурсы! Давайте поэтому введем аунтефикацию.  

API аунтефикации: 

1. `POST /register, body: json{username,password}`: Регистрация нового пользователя.
2. `POST /login, body: json{username,password}`: Аутентификация пользователя и генерация токена.

Всем пользователям, которые обращаются к серверу без токена нужно отвечать `401 Unauthorized`.  
В качестве системы аунтефикации возьмите в основу модель сессий. Пользователь будет класть токен в хедер запроса 'Authorization' ('Authorization': Bearer {auth_token}).  

У вас был тип `Task`, теперь будет тип `User` = `struct User { id, login, password }`, `Session` - `struct Session {user_id, session_id}`. Добавьте в имеющийся `Storage` соответствующие методы для новых типов (их еще любят называть моделями, хотя Анджелиной Джоли тут и не пахнет).  

## Не спать на POSTу! :)

На паре мы поговорили про брокеры сообщений. Вам 5 секунд на то, чтобы понять - куда его впихнуть!  
Так вот, давайте попробуем теперь посылать запросы в `RabbitMQ` + напишем `Consumer'a` - и назовем его `{Image/Code}Processor` - 
в зависимости от того, какой проект вы выбрали.

Что же должен делать `Consumer`?  

### CodeProcessor

Чужой код нужно запускать в изолированной среде - лучше всего для этого подойдет `Docker`. Нам нужно заранее заготовить `Dockerfile`, в котором будет запускаться код. Давайте его создадим в отдельной папке процессора и скачаем туда пару базовых компиляторов: clang, gcc, и еще интерпретатор: python. Дальше с помощью библиотеки для каждой новой поссылки будем создавать докер контейнер - класть создавать внутри файл с пользовательским кодом, компилировать его, если требуется и запускать. В качестве результата мы будем брать `stdout`, `stderr` пользователя.  

### ImageProcessor

Получаем картинку (допустим, в формате png) - а далее делаем с ней все, что хотим! Можно добавить следующие фильтры из библиотеки: `Sharpen`, `Blur`. Также, два простеньких попробовать написать самому - `Negative`, `Отображение относительно оси X`. Как можно заметить фильтры - `Sharpen`, `Blur` имеют входной параметр, поэтому наш `JSON` с указанием фильтра теперь будет выглядеть так: `{"filter": {"name": <string>, "parameters": <json>}}`. В качестве результата будет измененная картинка.

## Коммит

Куда положить результат выполнения `Consumer'ов`? Лучше всего это сделать в базу напрямую, но пока мы не знаем, что это такое, если бы мы знали что это такое... Давайте пока что в виде временного решения обойдемся просто ручкой `/commit` у нашего HTTP сервера, для того, чтобы тесты работали. (В случае с картинкой нужно сделать так, чтобы картинка отображалась в браузере при запросе /result)

## Запускаем все вместе

Напишите `docker-compose` файл для запуска `HTTP` сервера, `RabbitMQ`, `Processor`'a.  
Прокиньте туда файл `tests.py`. Настройте `Makefile`!  

# Материалы

[Как можно работать с сессиями](https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/06.2.html) - можете отсюда посмотреть, как генерировать SessionID.    
[RabbitMQ](https://www.rabbitmq.com/tutorials)
[Фильтры для ImageProcessor'a на Golang](github.com/disintegration/imaging)
[Клиент докера для CodeProcessor'a на Golang](https://github.com/moby/moby)  
